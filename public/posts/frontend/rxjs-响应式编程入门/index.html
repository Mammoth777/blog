<!doctype html><html lang=en dir=auto><head><script src="/blog/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=blog/livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RxJS 响应式编程入门 | Hoi !</title>
<meta name=keywords content><meta name=description content="为什么需要 Observable RxJS 说是弥补关于数据处理场景的一块空白 → 推送多个数据。
这里把我们对数据的处理方式做了两个维度的分类：
Type SINGLE MULTIPLE Pull Function Iterator Push Promise Observable Pull 和 Push Pull 就是我要的时候，就能要到。生产者无感。
每个 JS 函数都是在 Pull ES2015 的生成器（function*）弥补了&#34;拉取多个值&#34;的空白 Push 就是我决定啥时候给，消费者无感。
典型例子就是 Promise，等 then 的时候自然会 push 给你 从生产者和消费者的角度理解：
生产者 消费者 Pull 被动：等着要数据的时候再产生数据 主动：会决定啥时候去要数据 Push 主动：按照自己的节奏产生数据，然后推出去 被动：就等着数据（等回调） 代码示例 1. 拉取单个数据
function getNum() { return Math.floor(Math.random() * 10) } function singlePull() { const num = getNum() console.log(num, 'singlePull') } 2. 推送单个数据
function getNumPromise() { return new Promise((resolve, reject) => { setTimeout(() => { resolve(getNum()) }, 1000) }) } function singlePush() { const promise = getNumPromise() promise."><meta name=author content="Jachy"><link rel=canonical href=http://localhost:1313/blog/posts/frontend/rxjs-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/blog/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/blog/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/blog/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/blog/posts/frontend/rxjs-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "cc290be69327495eab8d7febf9b55bdb"}'></script><meta property="og:title" content="RxJS 响应式编程入门"><meta property="og:description" content="为什么需要 Observable RxJS 说是弥补关于数据处理场景的一块空白 → 推送多个数据。
这里把我们对数据的处理方式做了两个维度的分类：
Type SINGLE MULTIPLE Pull Function Iterator Push Promise Observable Pull 和 Push Pull 就是我要的时候，就能要到。生产者无感。
每个 JS 函数都是在 Pull ES2015 的生成器（function*）弥补了&#34;拉取多个值&#34;的空白 Push 就是我决定啥时候给，消费者无感。
典型例子就是 Promise，等 then 的时候自然会 push 给你 从生产者和消费者的角度理解：
生产者 消费者 Pull 被动：等着要数据的时候再产生数据 主动：会决定啥时候去要数据 Push 主动：按照自己的节奏产生数据，然后推出去 被动：就等着数据（等回调） 代码示例 1. 拉取单个数据
function getNum() { return Math.floor(Math.random() * 10) } function singlePull() { const num = getNum() console.log(num, 'singlePull') } 2. 推送单个数据
function getNumPromise() { return new Promise((resolve, reject) => { setTimeout(() => { resolve(getNum()) }, 1000) }) } function singlePush() { const promise = getNumPromise() promise."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/blog/posts/frontend/rxjs-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"><meta property="og:image" content="http://localhost:1313/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-11T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-11T00:00:00+00:00"><meta property="og:site_name" content="Jachy's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="RxJS 响应式编程入门"><meta name=twitter:description content="为什么需要 Observable RxJS 说是弥补关于数据处理场景的一块空白 → 推送多个数据。
这里把我们对数据的处理方式做了两个维度的分类：
Type SINGLE MULTIPLE Pull Function Iterator Push Promise Observable Pull 和 Push Pull 就是我要的时候，就能要到。生产者无感。
每个 JS 函数都是在 Pull ES2015 的生成器（function*）弥补了&#34;拉取多个值&#34;的空白 Push 就是我决定啥时候给，消费者无感。
典型例子就是 Promise，等 then 的时候自然会 push 给你 从生产者和消费者的角度理解：
生产者 消费者 Pull 被动：等着要数据的时候再产生数据 主动：会决定啥时候去要数据 Push 主动：按照自己的节奏产生数据，然后推出去 被动：就等着数据（等回调） 代码示例 1. 拉取单个数据
function getNum() { return Math.floor(Math.random() * 10) } function singlePull() { const num = getNum() console.log(num, 'singlePull') } 2. 推送单个数据
function getNumPromise() { return new Promise((resolve, reject) => { setTimeout(() => { resolve(getNum()) }, 1000) }) } function singlePush() { const promise = getNumPromise() promise."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/blog/posts/"},{"@type":"ListItem","position":2,"name":"RxJS 响应式编程入门","item":"http://localhost:1313/blog/posts/frontend/rxjs-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RxJS 响应式编程入门","name":"RxJS 响应式编程入门","description":"为什么需要 Observable RxJS 说是弥补关于数据处理场景的一块空白 → 推送多个数据。\n这里把我们对数据的处理方式做了两个维度的分类：\nType SINGLE MULTIPLE Pull Function Iterator Push Promise Observable Pull 和 Push Pull 就是我要的时候，就能要到。生产者无感。\n每个 JS 函数都是在 Pull ES2015 的生成器（function*）弥补了\u0026quot;拉取多个值\u0026quot;的空白 Push 就是我决定啥时候给，消费者无感。\n典型例子就是 Promise，等 then 的时候自然会 push 给你 从生产者和消费者的角度理解：\n生产者 消费者 Pull 被动：等着要数据的时候再产生数据 主动：会决定啥时候去要数据 Push 主动：按照自己的节奏产生数据，然后推出去 被动：就等着数据（等回调） 代码示例 1. 拉取单个数据\nfunction getNum() { return Math.floor(Math.random() * 10) } function singlePull() { const num = getNum() console.log(num, \u0026#39;singlePull\u0026#39;) } 2. 推送单个数据\nfunction getNumPromise() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(getNum()) }, 1000) }) } function singlePush() { const promise = getNumPromise() promise.","keywords":[],"articleBody":"为什么需要 Observable RxJS 说是弥补关于数据处理场景的一块空白 → 推送多个数据。\n这里把我们对数据的处理方式做了两个维度的分类：\nType SINGLE MULTIPLE Pull Function Iterator Push Promise Observable Pull 和 Push Pull 就是我要的时候，就能要到。生产者无感。\n每个 JS 函数都是在 Pull ES2015 的生成器（function*）弥补了\"拉取多个值\"的空白 Push 就是我决定啥时候给，消费者无感。\n典型例子就是 Promise，等 then 的时候自然会 push 给你 从生产者和消费者的角度理解：\n生产者 消费者 Pull 被动：等着要数据的时候再产生数据 主动：会决定啥时候去要数据 Push 主动：按照自己的节奏产生数据，然后推出去 被动：就等着数据（等回调） 代码示例 1. 拉取单个数据\nfunction getNum() { return Math.floor(Math.random() * 10) } function singlePull() { const num = getNum() console.log(num, 'singlePull') } 2. 推送单个数据\nfunction getNumPromise() { return new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e { resolve(getNum()) }, 1000) }) } function singlePush() { const promise = getNumPromise() promise.then(num =\u003e console.log(num, 'singlePush')) } 3. 拉取多个数据\nfunction* getNumIterator() { let i = 0; while (i \u003c 3) { i++; yield getNum(); } return i; } function multiplePull() { const it = getNumIterator() while (true) { const { value, done } = it.next() if (done) break console.log(value, 'multiplePull') } } 4. 推送多个数据\nfunction getNumObservable() { return new Observable(subscriber =\u003e { subscriber.next(getNum()) subscriber.next(getNum()) subscriber.next(getNum()) setTimeout(() =\u003e { subscriber.next(getNum()) subscriber.complete() }, 200) }) } function multiplePush() { const ob = getNumObservable() ob.subscribe(val =\u003e { console.log(val, 'multiplePush') }) } 核心概念 英文 中文 描述 Observable 可观察对象 可调用的未来值或事件的集合 Observer 观察者 知道如何去监听由 Observable 提供的值 Subscription 订阅 Observable 的执行，主要用于取消 Observable 的执行 Operators 操作符 纯函数，如 map, filter, concat, flatmap 等处理集合 Subject 主体 相当于 EventEmitter，是将多值或事件多路推送给多个 Observer 的唯一方式 Scheduler 调度器 用来控制并发，中央集权的调度员 个人理解 Observable: 核心集合对象。会（在未来）产生值和事件。 Observer: 对 Observable 产生的值和事件的处理函数。 Subscription: 代表 Observable 的执行实例，可用于结束 Observable。 Operators: 操作符，一系列无副作用函数。 Subject: 唯一的多播（multicasting）方式，可多播到多个 Observer。 Scheduler: 控制并发，类似于一个共用的锁。 Observable 的使用 创建 Observable 方式一：new 一个\nconst ob = new Observable(subscriber =\u003e { subscriber.next(1) subscriber.next(2) subscriber.complete() }) 方式二：使用操作符\nof(1, 2, 3) from([1, 2, 3]) interval(200) 订阅 Observable of(1,2,3).subscribe(val =\u003e { console.log(val, 'of') }) 取消订阅 const subscription = interval(200).subscribe(val =\u003e { console.log(val, 'interval'); }) setTimeout(() =\u003e subscription.unsubscribe(), 1000) Observable 的执行时机 重要：Observable 是在被 subscribe 了才执行的。\n这是理解\"多播\"与\"单播\"的关键点：\nlet n = 0; function getNum() { return n++; } const ob = new Observable(subscriber =\u003e { subscriber.next(getNum()); }) console.log(n) // 0 ob.subscribe(val =\u003e console.log(val, 'unicast')); // 1 参考：RxJS Official - Executing Observables\nObserver Observer 是一个消费者，消费的是 Observable 中流转的值。是一个最多有 3 个回调函数的对象。\nconst observer = { next: x =\u003e console.log('Observer got a next value: ' + x), error: err =\u003e console.error('Observer got an error: ' + err), complete: () =\u003e console.log('Observer got a complete notification'), } 注：回调可以省略。\n使用示例：\nconst ob = new Observable(subscriber =\u003e { subscriber.next(1) subscriber.next(2) subscriber.next(3)\tsubscriber.complete() }) ob.subscribe(observer) Subject 多播 vs 单播 RxJS Subject 是一个特殊类型的 Observable，核心点就是它是多播（multicast）的。普通的 Observable 是单播的（unicast）。\nconst { Observable, Subject } = require(\"rxjs\"); let n = 0; function getNum() { return n++; } // 单播：每次订阅都会重新执行 const unicastObservable = new Observable(observer =\u003e { observer.next(getNum()); }) unicastObservable.subscribe(val =\u003e console.log(val, 'unicast')); // 0 unicastObservable.subscribe(val =\u003e console.log(val, 'unicast')); // 1 // 多播：多次订阅共享一次计算结果 const multicastObservable = new Subject(); setTimeout(() =\u003e { multicastObservable.next(getNum()); }, 0); multicastObservable.subscribe(val =\u003e console.log(val, 'multicast')); // 2 multicastObservable.subscribe(val =\u003e console.log(val, 'multicast')); // 2 单播（unicast）: 每订阅（subscribe）一次，就执行了一次 多播（multicast）: 多次订阅，共享的一次计算结果 Operators 操作符 RxJS 有两类操作符：Pipeable Operators 和 Creation Operators\nCreation Operators 可以理解为一种生成新的 Observable 的独立函数。比如 of(1,2,3) 生成一个 Observable，会一个个发出 1, 2, 3。\nPipeable Operators 本质上就是一个纯函数，输入 Observable，输出新的 Observable。\nconst { Observable, pipe, filter } = require('rxjs') const observable = new Observable(observer =\u003e { observer.next(1) observer.next(2) observer.next(3) observer.next(4) }) // 通过 pipe 构建自己的 operator function onlyEven() { return pipe( filter((value) =\u003e value % 2 === 0) ) } observable.pipe( onlyEven() ).subscribe(v =\u003e console.log(v)) // 2, 4 参考：RxJS Official - Operators\nSubscription Subscription 是一个对象，表示一次性资源，常作为一个 Observable 的执行器。有一个重要的方法是 unsubscribe 用于取消订阅。\n本质上就是一个 Observable 的执行对象，保存着一个取消订阅的方法。\nconst { interval } = require('rxjs'); const obab = interval(200) const subscription = obab.subscribe(val =\u003e console.log(val, 'interval')) setTimeout(() =\u003e { subscription.unsubscribe() }, 2000); Scheduler Scheduler 负责控制 subscription 的开始和数据的传输。\n涉及知识点：JS 执行机制\n参考：\nRxJS: Scheduler RxJS: 认识 Scheduler API 速查 interval(period: number, scheduler) 隔 period 毫秒产生一个递增数字。\ninterval(200) // 每 200ms 发出一个递增数字 总结：RxJS 是一个强大的响应式编程库，核心是 Observable。理解 Pull/Push、单播/多播、以及各类操作符的用法，是掌握 RxJS 的关键。\n","wordCount":"593","inLanguage":"en","image":"http://localhost:1313/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-01-11T00:00:00Z","dateModified":"2024-01-11T00:00:00Z","author":{"@type":"Person","name":"Jachy"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/blog/posts/frontend/rxjs-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},"publisher":{"@type":"Organization","name":"Hoi !","logo":{"@type":"ImageObject","url":"http://localhost:1313/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/blog/ accesskey=h title="Jachy's Blog (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Jachy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/blog/ title=Home><span>Home</span></a></li><li><a href=http://localhost:1313/blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/blog/archives title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/blog/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/blog/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/blog/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">RxJS 响应式编程入门</h1><div class=post-meta><span title='2024-01-11 00:00:00 +0000 UTC'>January 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;593 words&nbsp;·&nbsp;Jachy&nbsp;|&nbsp;<a href=https://github.com/Mammoth777/blog/tree/main/content/posts/frontend/RxJS%20%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%85%a5%e9%97%a8.md rel="noopener noreferrer" target=_blank>source</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#为什么需要-observable>为什么需要 Observable</a><ul><li><a href=#pull-和-push>Pull 和 Push</a></li><li><a href=#代码示例>代码示例</a></li></ul></li><li><a href=#核心概念>核心概念</a><ul><li><a href=#个人理解>个人理解</a></li></ul></li><li><a href=#observable-的使用>Observable 的使用</a><ul><li><a href=#创建-observable>创建 Observable</a></li><li><a href=#订阅-observable>订阅 Observable</a></li><li><a href=#取消订阅>取消订阅</a></li><li><a href=#observable-的执行时机>Observable 的执行时机</a></li></ul></li><li><a href=#observer>Observer</a></li><li><a href=#subject-多播-vs-单播>Subject 多播 vs 单播</a></li><li><a href=#operators-操作符>Operators 操作符</a><ul><li><a href=#creation-operators>Creation Operators</a></li><li><a href=#pipeable-operators>Pipeable Operators</a></li></ul></li><li><a href=#subscription>Subscription</a></li><li><a href=#scheduler>Scheduler</a></li><li><a href=#api-速查>API 速查</a><ul><li><a href=#intervalperiod-number-scheduler><code>interval(period: number, scheduler)</code></a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=为什么需要-observable>为什么需要 Observable<a hidden class=anchor aria-hidden=true href=#为什么需要-observable>#</a></h2><p>RxJS 说是弥补关于数据处理场景的一块空白 → <strong>推送多个数据</strong>。</p><p>这里把我们对数据的处理方式做了两个维度的分类：</p><table><thead><tr><th>Type</th><th>SINGLE</th><th>MULTIPLE</th></tr></thead><tbody><tr><td>Pull</td><td>Function</td><td>Iterator</td></tr><tr><td>Push</td><td>Promise</td><td><strong>Observable</strong></td></tr></tbody></table><h3 id=pull-和-push>Pull 和 Push<a hidden class=anchor aria-hidden=true href=#pull-和-push>#</a></h3><p><strong>Pull</strong> 就是我要的时候，就能要到。生产者无感。</p><ul><li>每个 JS 函数都是在 Pull</li><li>ES2015 的生成器（<code>function*</code>）弥补了"拉取多个值"的空白</li></ul><p><strong>Push</strong> 就是我决定啥时候给，消费者无感。</p><ul><li>典型例子就是 <code>Promise</code>，等 <code>then</code> 的时候自然会 <code>push</code> 给你</li></ul><p>从生产者和消费者的角度理解：</p><table><thead><tr><th></th><th>生产者</th><th>消费者</th></tr></thead><tbody><tr><td>Pull</td><td>被动：等着要数据的时候再产生数据</td><td>主动：会决定啥时候去要数据</td></tr><tr><td>Push</td><td>主动：按照自己的节奏产生数据，然后推出去</td><td>被动：就等着数据（等回调）</td></tr></tbody></table><h3 id=代码示例>代码示例<a hidden class=anchor aria-hidden=true href=#代码示例>#</a></h3><p><strong>1. 拉取单个数据</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>getNum() {</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>floor</span><span class=p>(</span><span class=nb>Math</span><span class=p>.</span><span class=nx>random</span><span class=p>()</span> <span class=o>*</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>singlePull() {</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>num</span> <span class=o>=</span> <span class=nx>getNum</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>num</span><span class=p>,</span> <span class=s1>&#39;singlePull&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>2. 推送单个数据</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>getNumPromise() {</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>new</span> <span class=nx>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setTimeout</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>resolve</span><span class=p>(</span><span class=nx>getNum</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>singlePush() {</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>promise</span> <span class=o>=</span> <span class=nx>getNumPromise</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nx>promise</span><span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>num</span> <span class=o>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>num</span><span class=p>,</span> <span class=s1>&#39;singlePush&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>3. 拉取多个数据</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kd>function</span><span class=o>*</span> <span class=nx>getNumIterator() {</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=nx>i</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>yield</span> <span class=nx>getNum</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>multiplePull() {</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>it</span> <span class=o>=</span> <span class=nx>getNumIterator</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=kc>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=p>{</span> <span class=nx>value</span><span class=p>,</span> <span class=nx>done</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>it</span><span class=p>.</span><span class=nx>next</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>done</span><span class=p>)</span> <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>value</span><span class=p>,</span> <span class=s1>&#39;multiplePull&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>4. 推送多个数据</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>getNumObservable() {</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=k>new</span> <span class=nx>Observable</span><span class=p>(</span><span class=nx>subscriber</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>subscriber</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=nx>getNum</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>subscriber</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=nx>getNum</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>subscriber</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=nx>getNum</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=nx>setTimeout</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>subscriber</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=nx>getNum</span><span class=p>())</span>
</span></span><span class=line><span class=cl>      <span class=nx>subscriber</span><span class=p>.</span><span class=nx>complete</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span> <span class=mi>200</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>multiplePush() {</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>ob</span> <span class=o>=</span> <span class=nx>getNumObservable</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nx>ob</span><span class=p>.</span><span class=nx>subscribe</span><span class=p>(</span><span class=nx>val</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>val</span><span class=p>,</span> <span class=s1>&#39;multiplePush&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=核心概念>核心概念<a hidden class=anchor aria-hidden=true href=#核心概念>#</a></h2><table><thead><tr><th>英文</th><th>中文</th><th>描述</th></tr></thead><tbody><tr><td>Observable</td><td>可观察对象</td><td>可调用的未来值或事件的集合</td></tr><tr><td>Observer</td><td>观察者</td><td>知道如何去监听由 Observable 提供的值</td></tr><tr><td>Subscription</td><td>订阅</td><td>Observable 的执行，主要用于取消 Observable 的执行</td></tr><tr><td>Operators</td><td>操作符</td><td>纯函数，如 map, filter, concat, flatmap 等处理集合</td></tr><tr><td>Subject</td><td>主体</td><td>相当于 EventEmitter，是将多值或事件多路推送给多个 Observer 的唯一方式</td></tr><tr><td>Scheduler</td><td>调度器</td><td>用来控制并发，中央集权的调度员</td></tr></tbody></table><h3 id=个人理解>个人理解<a hidden class=anchor aria-hidden=true href=#个人理解>#</a></h3><ul><li><strong>Observable</strong>: 核心集合对象。会（在未来）产生值和事件。</li><li><strong>Observer</strong>: 对 Observable 产生的值和事件的处理函数。</li><li><strong>Subscription</strong>: 代表 Observable 的执行实例，可用于结束 Observable。</li><li><strong>Operators</strong>: 操作符，一系列无副作用函数。</li><li><strong>Subject</strong>: 唯一的多播（multicasting）方式，可多播到多个 Observer。</li><li><strong>Scheduler</strong>: 控制并发，类似于一个共用的锁。</li></ul><h2 id=observable-的使用>Observable 的使用<a hidden class=anchor aria-hidden=true href=#observable-的使用>#</a></h2><h3 id=创建-observable>创建 Observable<a hidden class=anchor aria-hidden=true href=#创建-observable>#</a></h3><p><strong>方式一：new 一个</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>ob</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Observable</span><span class=p>(</span><span class=nx>subscriber</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>subscriber</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>subscriber</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>subscriber</span><span class=p>.</span><span class=nx>complete</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p><strong>方式二：使用操作符</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=k>of</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kr>from</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nx>interval</span><span class=p>(</span><span class=mi>200</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=订阅-observable>订阅 Observable<a hidden class=anchor aria-hidden=true href=#订阅-observable>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=k>of</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>).</span><span class=nx>subscribe</span><span class=p>(</span><span class=nx>val</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>val</span><span class=p>,</span> <span class=s1>&#39;of&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><h3 id=取消订阅>取消订阅<a hidden class=anchor aria-hidden=true href=#取消订阅>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>subscription</span> <span class=o>=</span> <span class=nx>interval</span><span class=p>(</span><span class=mi>200</span><span class=p>).</span><span class=nx>subscribe</span><span class=p>(</span><span class=nx>val</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>val</span><span class=p>,</span> <span class=s1>&#39;interval&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=nx>subscription</span><span class=p>.</span><span class=nx>unsubscribe</span><span class=p>(),</span> <span class=mi>1000</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=observable-的执行时机>Observable 的执行时机<a hidden class=anchor aria-hidden=true href=#observable-的执行时机>#</a></h3><p><strong>重要：Observable 是在被 subscribe 了才执行的。</strong></p><p>这是理解"多播"与"单播"的关键点：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>getNum</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>n</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>ob</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Observable</span><span class=p>(</span><span class=nx>subscriber</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>subscriber</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=nx>getNum</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=c1>// 0
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>ob</span><span class=p>.</span><span class=nx>subscribe</span><span class=p>(</span><span class=nx>val</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>val</span><span class=p>,</span> <span class=s1>&#39;unicast&#39;</span><span class=p>));</span> <span class=c1>// 1
</span></span></span></code></pre></div><p>参考：<a href=https://rxjs.dev/guide/observable#executing-observables>RxJS Official - Executing Observables</a></p><h2 id=observer>Observer<a hidden class=anchor aria-hidden=true href=#observer>#</a></h2><blockquote><p>Observer 是一个消费者，消费的是 Observable 中流转的值。是一个最多有 3 个回调函数的对象。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>observer</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>next</span>: <span class=kt>x</span> <span class=o>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Observer got a next value: &#39;</span> <span class=o>+</span> <span class=nx>x</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nx>error</span>: <span class=kt>err</span> <span class=o>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=s1>&#39;Observer got an error: &#39;</span> <span class=o>+</span> <span class=nx>err</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=nx>complete</span><span class=o>:</span> <span class=p>()</span> <span class=o>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Observer got a complete notification&#39;</span><span class=p>),</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注：回调可以省略。</p><p>使用示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>ob</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Observable</span><span class=p>(</span><span class=nx>subscriber</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>subscriber</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>subscriber</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>subscriber</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>	
</span></span><span class=line><span class=cl>  <span class=nx>subscriber</span><span class=p>.</span><span class=nx>complete</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl><span class=nx>ob</span><span class=p>.</span><span class=nx>subscribe</span><span class=p>(</span><span class=nx>observer</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=subject-多播-vs-单播>Subject 多播 vs 单播<a hidden class=anchor aria-hidden=true href=#subject-多播-vs-单播>#</a></h2><blockquote><p>RxJS Subject 是一个特殊类型的 Observable，核心点就是它是<strong>多播</strong>（multicast）的。普通的 Observable 是<strong>单播</strong>的（unicast）。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=p>{</span> <span class=nx>Observable</span><span class=p>,</span> <span class=nx>Subject</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;rxjs&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>getNum</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>n</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 单播：每次订阅都会重新执行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>unicastObservable</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Observable</span><span class=p>(</span><span class=nx>observer</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>observer</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=nx>getNum</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>unicastObservable</span><span class=p>.</span><span class=nx>subscribe</span><span class=p>(</span><span class=nx>val</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>val</span><span class=p>,</span> <span class=s1>&#39;unicast&#39;</span><span class=p>));</span> <span class=c1>// 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>unicastObservable</span><span class=p>.</span><span class=nx>subscribe</span><span class=p>(</span><span class=nx>val</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>val</span><span class=p>,</span> <span class=s1>&#39;unicast&#39;</span><span class=p>));</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 多播：多次订阅共享一次计算结果
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>multicastObservable</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Subject</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>multicastObservable</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=nx>getNum</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>multicastObservable</span><span class=p>.</span><span class=nx>subscribe</span><span class=p>(</span><span class=nx>val</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>val</span><span class=p>,</span> <span class=s1>&#39;multicast&#39;</span><span class=p>));</span> <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>multicastObservable</span><span class=p>.</span><span class=nx>subscribe</span><span class=p>(</span><span class=nx>val</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>val</span><span class=p>,</span> <span class=s1>&#39;multicast&#39;</span><span class=p>));</span> <span class=c1>// 2
</span></span></span></code></pre></div><ul><li><strong>单播（unicast）</strong>: 每订阅（subscribe）一次，就执行了一次</li><li><strong>多播（multicast）</strong>: 多次订阅，共享的一次计算结果</li></ul><h2 id=operators-操作符>Operators 操作符<a hidden class=anchor aria-hidden=true href=#operators-操作符>#</a></h2><p>RxJS 有两类操作符：<strong>Pipeable Operators</strong> 和 <strong>Creation Operators</strong></p><h3 id=creation-operators>Creation Operators<a hidden class=anchor aria-hidden=true href=#creation-operators>#</a></h3><p>可以理解为一种生成新的 Observable 的独立函数。比如 <code>of(1,2,3)</code> 生成一个 Observable，会一个个发出 1, 2, 3。</p><h3 id=pipeable-operators>Pipeable Operators<a hidden class=anchor aria-hidden=true href=#pipeable-operators>#</a></h3><p>本质上就是一个纯函数，输入 Observable，输出新的 Observable。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=p>{</span> <span class=nx>Observable</span><span class=p>,</span> <span class=nx>pipe</span><span class=p>,</span> <span class=nx>filter</span> <span class=p>}</span> <span class=o>=</span> <span class=kr>require</span><span class=p>(</span><span class=s1>&#39;rxjs&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>observable</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Observable</span><span class=p>(</span><span class=nx>observer</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>observer</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>observer</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>observer</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nx>observer</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 通过 pipe 构建自己的 operator
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>onlyEven() {</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>pipe</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>filter</span><span class=p>((</span><span class=nx>value</span><span class=p>)</span> <span class=o>=&gt;</span> <span class=nx>value</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>===</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>observable</span><span class=p>.</span><span class=nx>pipe</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=nx>onlyEven</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>).</span><span class=nx>subscribe</span><span class=p>(</span><span class=nx>v</span> <span class=o>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>v</span><span class=p>))</span> <span class=c1>// 2, 4
</span></span></span></code></pre></div><p>参考：<a href=https://rxjs.dev/guide/operators>RxJS Official - Operators</a></p><h2 id=subscription>Subscription<a hidden class=anchor aria-hidden=true href=#subscription>#</a></h2><blockquote><p>Subscription 是一个对象，表示一次性资源，常作为一个 Observable 的执行器。有一个重要的方法是 <code>unsubscribe</code> 用于取消订阅。</p></blockquote><p>本质上就是一个 <code>Observable</code> 的执行对象，保存着一个取消订阅的方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=kr>const</span> <span class=p>{</span> <span class=nx>interval</span> <span class=p>}</span> <span class=o>=</span> <span class=kr>require</span><span class=p>(</span><span class=s1>&#39;rxjs&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>obab</span> <span class=o>=</span> <span class=nx>interval</span><span class=p>(</span><span class=mi>200</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>subscription</span> <span class=o>=</span> <span class=nx>obab</span><span class=p>.</span><span class=nx>subscribe</span><span class=p>(</span><span class=nx>val</span> <span class=o>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>val</span><span class=p>,</span> <span class=s1>&#39;interval&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>subscription</span><span class=p>.</span><span class=nx>unsubscribe</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>2000</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=scheduler>Scheduler<a hidden class=anchor aria-hidden=true href=#scheduler>#</a></h2><blockquote><p>Scheduler 负责控制 subscription 的开始和数据的传输。</p></blockquote><p>涉及知识点：JS 执行机制</p><p>参考：</p><ul><li><a href=https://rxjs.dev/guide/scheduler>RxJS: Scheduler</a></li><li><a href=https://fullstackladder.dev/blog/2020/10/19/mastering-rxjs-34-introduce-scheduler-of-rxjs/>RxJS: 认识 Scheduler</a></li></ul><h2 id=api-速查>API 速查<a hidden class=anchor aria-hidden=true href=#api-速查>#</a></h2><h3 id=intervalperiod-number-scheduler><code>interval(period: number, scheduler)</code><a hidden class=anchor aria-hidden=true href=#intervalperiod-number-scheduler>#</a></h3><p>隔 period 毫秒产生一个递增数字。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-typescript data-lang=typescript><span class=line><span class=cl><span class=nx>interval</span><span class=p>(</span><span class=mi>200</span><span class=p>)</span> <span class=c1>// 每 200ms 发出一个递增数字
</span></span></span></code></pre></div><hr><p><strong>总结</strong>：RxJS 是一个强大的响应式编程库，核心是 Observable。理解 Pull/Push、单播/多播、以及各类操作符的用法，是掌握 RxJS 的关键。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/blog/posts/frontend/eventloop/><span class=title>« Prev</span><br><span>浏览器事件循环-微任务和宏任务，调用栈，渲染队列：布局，绘制与合成</span>
</a><a class=next href=http://localhost:1313/blog/posts/frontend/chrome-%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E8%AF%A6%E8%A7%A3/><span class=title>Next »</span><br><span>Chrome 性能指标详解</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share RxJS 响应式编程入门 on x" href="https://x.com/intent/tweet/?text=RxJS%20%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%85%a5%e9%97%a8&amp;url=http%3a%2f%2flocalhost%3a1313%2fblog%2fposts%2ffrontend%2frxjs-%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E7%25BC%2596%25E7%25A8%258B%25E5%2585%25A5%25E9%2597%25A8%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share RxJS 响应式编程入门 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fblog%2fposts%2ffrontend%2frxjs-%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E7%25BC%2596%25E7%25A8%258B%25E5%2585%25A5%25E9%2597%25A8%2f&amp;title=RxJS%20%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%85%a5%e9%97%a8&amp;summary=RxJS%20%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%85%a5%e9%97%a8&amp;source=http%3a%2f%2flocalhost%3a1313%2fblog%2fposts%2ffrontend%2frxjs-%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E7%25BC%2596%25E7%25A8%258B%25E5%2585%25A5%25E9%2597%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share RxJS 响应式编程入门 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fblog%2fposts%2ffrontend%2frxjs-%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E7%25BC%2596%25E7%25A8%258B%25E5%2585%25A5%25E9%2597%25A8%2f&title=RxJS%20%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%85%a5%e9%97%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share RxJS 响应式编程入门 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fblog%2fposts%2ffrontend%2frxjs-%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E7%25BC%2596%25E7%25A8%258B%25E5%2585%25A5%25E9%2597%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share RxJS 响应式编程入门 on whatsapp" href="https://api.whatsapp.com/send?text=RxJS%20%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%85%a5%e9%97%a8%20-%20http%3a%2f%2flocalhost%3a1313%2fblog%2fposts%2ffrontend%2frxjs-%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E7%25BC%2596%25E7%25A8%258B%25E5%2585%25A5%25E9%2597%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share RxJS 响应式编程入门 on telegram" href="https://telegram.me/share/url?text=RxJS%20%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%85%a5%e9%97%a8&amp;url=http%3a%2f%2flocalhost%3a1313%2fblog%2fposts%2ffrontend%2frxjs-%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E7%25BC%2596%25E7%25A8%258B%25E5%2585%25A5%25E9%2597%25A8%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share RxJS 响应式编程入门 on ycombinator" href="https://news.ycombinator.com/submitlink?t=RxJS%20%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%85%a5%e9%97%a8&u=http%3a%2f%2flocalhost%3a1313%2fblog%2fposts%2ffrontend%2frxjs-%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E7%25BC%2596%25E7%25A8%258B%25E5%2585%25A5%25E9%2597%25A8%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://localhost:1313/blog/>Hoi !</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>